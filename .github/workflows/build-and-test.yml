name: Build and Test

on:
  push:
    branches: ["main"]
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Shallow clones should be disabled for a better relevancy of analysis
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'zulu' # Alternative distribution options are available
          cache: gradle
      - name: Build
        id: gradle
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
        run: ./gradlew chartsCheck --info --stacktrace

      - name: Test Summary
        if: always()
        run: |
          python3 - <<'PY'
          import os
          import xml.etree.ElementTree as ET
          from collections import defaultdict
          from pathlib import Path

          def discover_junit_xml():
              primary_dir = Path("charts/build/test-results/jvmTest")
              primary = sorted(primary_dir.glob("TEST-*.xml"))
              if primary:
                  return ("charts/build/test-results/jvmTest/TEST-*.xml", primary)

              # Fallback: any module/task JUnit XML
              xmls = []
              for p in Path(".").rglob("TEST-*.xml"):
                  parts = p.parts
                  for i in range(len(parts) - 2):
                      if parts[i] == "build" and parts[i + 1] == "test-results":
                          xmls.append(p)
                          break
              return ("**/build/test-results/**/TEST-*.xml", sorted(xmls))

          junit_pattern, xml_files = discover_junit_xml()

          def junit_group_key(path: Path) -> str:
              parts = path.parts
              module = None
              task = None
              for i, part in enumerate(parts):
                  if part == "build" and i > 0:
                      module = parts[i - 1]
                  if part == "test-results" and i + 1 < len(parts):
                      task = parts[i + 1]
              if module and task:
                  return f"{module}:{task}"
              return str(path.parent)

          def parse_junit_file(path: Path):
              try:
                  root = ET.parse(path).getroot()
              except ET.ParseError:
                  return None

              def iter_suites(r):
                  if r.tag == "testsuite":
                      yield r
                  else:
                      for ts in r.findall("testsuite"):
                          yield ts

              totals = {"tests": 0, "failures": 0, "errors": 0, "skipped": 0}
              failures = []

              def get_int(el, attr):
                  v = el.attrib.get(attr)
                  return int(v) if v and v.isdigit() else 0

              for suite in iter_suites(root):
                  totals["tests"] += get_int(suite, "tests")
                  totals["failures"] += get_int(suite, "failures")
                  totals["errors"] += get_int(suite, "errors")
                  totals["skipped"] += get_int(suite, "skipped")

                  for tc in suite.findall(".//testcase"):
                      name = tc.attrib.get("name", "")
                      classname = tc.attrib.get("classname", "")
                      if tc.find("failure") is not None or tc.find("error") is not None:
                          failures.append(f"{classname}.{name}" if classname else name)

              return totals, failures

          grouped = defaultdict(lambda: {"tests": 0, "failures": 0, "errors": 0, "skipped": 0, "failures_list": []})
          for f in xml_files:
              parsed = parse_junit_file(f)
              if not parsed:
                  continue
              totals, failures = parsed
              key = junit_group_key(f)
              g = grouped[key]
              for k in ("tests", "failures", "errors", "skipped"):
                  g[k] += totals[k]
              g["failures_list"].extend(failures)

          comment_path = "test-summary.md"
          with open(comment_path, "w", encoding="utf-8") as w:
              w.write("## Test Summary\\n\\n")

              w.write("### JUnit Tests\\n")
              w.write(f"- XML files discovered: {len(xml_files)} (pattern `{junit_pattern}`)\\n\\n")
              if grouped:
                  w.write("| Task | Total | Failed | Errors | Skipped |\\n")
                  w.write("| --- | ---: | ---: | ---: | ---: |\\n")
                  for key in sorted(grouped.keys()):
                      g = grouped[key]
                      w.write(f"| `{key}` | {g['tests']} | {g['failures']} | {g['errors']} | {g['skipped']} |\\n")
                  w.write("\\n")
              else:
                  w.write("- No JUnit XML found.\\n\\n")

              screenshot_report = Path("androidApp/build/reports/screenshotTest/preview/debug/index.html")
              w.write("### Screenshot Tests (`:androidApp:validateDebugScreenshotTest`)\\n")
              if screenshot_report.exists():
                  w.write("- Status: report generated\\n\\n")
              else:
                  w.write("- Status: no report generated\\n\\n")

          summary_path = os.environ.get("GITHUB_STEP_SUMMARY")
          if summary_path:
              with open(comment_path, "r", encoding="utf-8") as src, open(summary_path, "a", encoding="utf-8") as dst:
                  dst.write(src.read())
          PY

      - name: Post PR Comment
        if: always() && github.event_name == 'pull_request'
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body-path: test-summary.md
          edit-mode: replace
          comment-identifier: test-summary

      - name: Fail If Gradle Failed
        if: steps.gradle.outcome == 'failure'
        run: exit 1
